## Уровни веб-приложений


| Уровень | Сокращение | Функциональность |
|---------|------------|------------------|
| Уровень представления | PL | Отображение данных пользователю и принятие действий, ввод данных |
| Уровень обслуживания данных | DSL | Предоставление доступа к данным и эффективное использование, обработка ошибок ввода данных |
| Уровень бизнес-логики | BLL | Реализация бизнес-логики приложения, включая проверки прав и соблюдение правил приложения |
| Уровень доступа к данным | DAL | Работа с хранилищем данных, реализация CRUD-функций (создание, чтение, обновление, удаление данных) |


1. **Уровень представления** (Presentation layer): отвечает за то, как данные будут отображаться пользователю и обработку введенных им данных. Компоненты этого уровня обеспечивают взаимодействие с пользователем и передачу запросов на уровень бизнес-логики.

***Роль*** уровня представления в веб-приложении заключается в том, чтобы предоставлять пользователю удобный и понятный интерфейс для работы с приложением. Компоненты уровня представления занимаются отображением данных и интерактивными элементами управления, такими как кнопки, поля ввода и т.д. Уровень представления также отвечает за валидацию введенных пользователем данных, проверку прав доступа и перенаправление на другие страницы в приложении. Еще одна важная роль уровня представления заключается в обеспечении однородного и красивого дизайна сайта, который максимально соответствует бренду и концепции приложения.

2. **Уровень обслуживания данных** (DSL) - это слой в архитектуре приложения, который отвечает за доступ к данным внутри приложения. Он представляет собой программное обеспечение, которое предоставляет унифицированный интерфейс для работы с данными разных типов и форматов. 

***Роль*** уровня DSL - предоставлять удобный и эффективный доступ к данным внутри приложения, упрощать проектирование и тестирование приложений.

Уровень DSL может использовать различные технологии и инструменты для реализации механизма доступа к данным, такие как ODBC, JDBC, ADO.NET, Entity Framework и т.д. Он может предоставлять API (Application Programming Interface) для работы с данными, такие как CRUD операции (Create, Read, Update, Delete), фильтрацию, сортировку, поиск и т.д. Уровень DSL может также использовать кеширование данных для улучшения производительности приложения.

Роль уровня DSL в приложении состоит в том, чтобы предоставлять простой и единый интерфейс для работы с данными, скрыть специфики хранения данных, упростить проектирование приложения и улучшить его обслуживание. Благодаря уровню DSL приложение может работать с данными, хранимыми в разных источниках (например, базы данных, файлы, веб-сервисы), без необходимости знать специфики каждого источника и обслуживания каждого связанного с этим источника кода.

Таким образом, уровень DSL является ключевым компонентом современных приложений, которые работают с данными, и обеспечивает высокое качество приложений, упрощает их разработку и тестирование, а также обеспечивает быстрый и удобный доступ к данным.

3. **Уровень бизнес-логики** (Business logic layer): слой, где происходит обработка данных и принятие решений в соответствии с бизнес-правилами. Он содержит компоненты, которые обрабатывают запросы от уровня представления, производят необходимые расчеты и операции и возвращают результат обратно на уровень представления. 

*Роль* уровня бизнес-логики в веб-приложении заключается в обработке данных, которые были получены от уровня представления. Компоненты уровня бизнес-логики производят обработку данных с помощью бизнес-правил, которые определяют логику работы приложения. На этом уровне происходит реализация сценариев использования приложения и обработка ошибок, связанных с неверными данными. Уровень бизнес-логики также обеспечивает взаимодействие с другими системами, такими как базы данных, платежные системы, API и т.д. Этот уровень также отвечает за правильную работу приложения в зависимости от включенных функций, ролей и настроек. В результате этой обработки компоненты уровня бизнес-логики формируют результат и передают его обратно на уровень представления для отображения пользователю.

4. **Уровень доступа к данным** (Data access layer, DAL): уровень, который обеспечивает доступ к базе данных и предоставляет специфические для базы данных функции для уровня бизнес-логики. Он содержит классы и компоненты, которые выполняют чтение, запись и обновление данных в базе данных. 

***Роль*** уровня DAL в приложении заключается в том, чтобы отделить механизм работы с данными от бизнес-логики приложения. Это позволяет снизить связность компонентов приложения, улучшить его масштабируемость и обратную совместимость. Кроме того, с помощью DAL можно использовать различные источники данных без изменения кода приложения.

DAL обеспечивает доступ к данным с помощью стандартизированных интерфейсов, таких как SQL, ODBC, JDBC, ADO.NET, Entity Framework и т.д. Он также может содержать методы для обработки данных, например, фильтрации, сортировки, группировки и агрегации, а также защиту данных с помощью авторизации и аутентификации. Кроме того, уровень DAL может использовать кэширование данных для уменьшения нагрузки на сервисы баз данных и повышения производительности приложения.

За счет изоляции механизма работы с данными от бизнес-логики приложения, DAL облегчает тестирование и разработку приложения. Разработчики могут проводить модульное тестирование, используя мок-объекты или тестовые базы данных, без необходимости подключения и использования реальных сервисов баз данных.

В целом, уровень DAL играет важную роль в разработке приложений, обеспечивая доступ к данным, защиту данных, упрощение тестирования и разработки, а также повышение масштабируемости и обратной совместимости приложения.


Еще один уровень, который можно выделить — это уровень сервисов. Он содержит компоненты, которые предоставляют готовые сервисы для других уровней веб-приложения. Например, сервисы для работы с почтой, оплатой, аналитикой, и т.д.

___

### Монолитная и микросервисная архитектуры веб-приложения и различия между ними

**Монолитная архитектура веб-приложения**

**Монолитная** архитектура представляет собой классический подход к разработке приложений, где все компоненты находятся в едином кодовом блоке и взаимодействуют между собой через общее API. Это означает, что каждый разработчик может работать со всем приложением, а не только с отдельными его компонентами. 

Основным преимуществом монолитной архитектуры является ее простота и быстрота в развертывании. Это позволяет разработчикам быстро создавать и изменять функциональность приложений. Кроме того, монолитный подход помогает упросить интеграцию со сторонними сервисами. 

Недостатком монолитной архитектуры является невозможность масштабирования отдельных компонентов приложения. Это означает, что при увеличении нагрузки на один из компонентов может возникнуть нехватка ресурсов на сервере, что приведет к падению работы всего приложения. Кроме того, расширение функционала приложения может быть затруднено в связи с тем, что для этого придется изменять все его компоненты.

**Микросервисная архитектура веб-приложения**

**Микросервисная** архитектура представляет собой подход, основанный на использовании отдельных микросервисов, каждый из которых отвечает за определенную функциональную область. Каждый микросервис может быть написан на разных языках программирования и работать на разных серверах. 

Главным преимуществом микросервисной архитектуры является возможность масштабирования и расширения приложения в зависимости от потребностей каждого отдельного микросервиса. Также, микросервисный подход помогает сократить время разработки, так как каждый микросервис может быть написан и развернут независимо от других сервисов. 

Однако, микросервисная архитектура также имеет свои недостатки. В основном это связано с увеличением числа отдельных микросервисов. Когда их становится слишком много, то может возникнуть сложность с управлением версиями и настройками всех этих сервисов. Кроме того, работа со множеством сервисов может привести к взаимодействию с большим количеством API, что может снизить производительность приложения. 

**Различия между монолитной и микросервисной архитектурами**

1. Размер и структура приложения. Монолитные приложения состоят из одного блока кода. Микросервисные приложения представляют собой набор небольших сервисов, каждый из которых отвечает за конкретную функциональность.

2. Отношение между компонентами. В монолитных приложениях компоненты взаимодействуют между собой через единый API. В микросервисных приложениях компоненты взаимодействуют между собой часто по протоколу HTTP.

3. Масштабирование. Монолитные приложения масштабируются вертикально, т.е. добавлением ресурсов на сервер. Микросервисные приложения могут масштабироваться как вертикально, так и горизонтально, т.е. с помощью добавления новых серверов.

4. Управление. Монолитные приложения управляются централизовано. Микросервисные приложения могут управляться как централизовано, так и децентрализовано, в зависимости от потребностей и доступных ресурсов.

5. Самостоятельность. В монолитных приложениях все компоненты зависят друг от друга. В микросервисных приложениях каждый сервис может работать независимо от других сервисов и быть написан на разных языках программирования.

***Основная причина, по которой не все приложения основаны на микросервисной архитектуре***, заключается в том, что она относительно новый подход и не все команды разработчиков готовы к ней. Микросервисная архитектура требует более глубокого понимания всех ее аспектов и большей работы по ее внедрению, поэтому для многих она может быть непривычной или сложной.

Кроме того, выбор между монолитной и микросервисной архитектурой зависит от характеристик конкретного проекта. Если приложение небольшое и не нуждается в ***масштабировании***, то монолитная архитектура может быть более эффективной. Она более проста в реализации и позволяет быстро запустить приложение.

Однако приложения, которые предполагается будет масштабировать, лучше разрабатывать в микросервисной архитектуре, так как она позволяет распределить нагрузку на несколько сервисов и повысить его отказоустойчивость. Также при использовании микросервисов, меньше вероятность поломки всего приложения, если один из микросервисов отказал.

В итоге выбор между монолитным и микросервисным подходом зависит от характеристик проекта и его требований и должен основываться на более глубоком понимании всех аспектов их внедрения.

